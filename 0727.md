## 0727



**5~7p**

상속 Inheritance

- 기존 클래스의 속성과 메서드를 물려받아 새로운 하위 클래스를 생성하는 것
- 재사용하여 중복된 코드를 줄일 수 있따.
- 클래스들 간의 계층 구조를 형성할 수 있다.
- 유지 보수가 용이해진다.



**11p**

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def talk(self):
        print(f'안녕, {self.name}입니다.')


class Professor(Person):
    def __init__(self, name, age, department):
        Person.__init__(self, name, age)
        self.department = department


class Student(Person):
    def __init__(self, name, age, gpa):
        Person.__init__(self, name, age)
        self.gpa = gpa


p1 = Professor('박교수', 49, '컴공')
s1 = Student('김학생', 20, 3.5)

p1.talk()
s1.talk()

# 문제점: 만약 Person 함수 이름이 바뀌면, 하나하나 다 바꿔야한다. 유연하지가 못하다.
# 사실 상속은 여러개를 가질 수가 있다. 다중 상속
```



**12p**

super() 함수

**부모 class가 많은 상황에서 메서드 호출 순서에 맞는 부모 class를 알아서 호출해줌**

```python
class Student(Person):
    def __init__(self, name, age, gpa):
        # Person.__init__(self, name, age)
        super().__init__(name, age) # self도 사라짐!
        self.gpa = gpa
```



**15p**

다중 상속

- 두 개 이상의 클래스를 상속 받는 경우
- 중복된 속성이나 메서드가 있는 경우 **상속 순서**에 의해 결정 됨

```python
class Person:
    gene = 'XYZ'

    def __init__(self, name):
        self.name = name

    def greeting(self):
        return f'안녕, {self.name}'


class Mom(Person):
    gene = 'XX'

    def __init__(self, name): # 이게 없어도 되지만 생략을 해도 돌아간다.
        super().__init__(name) # 이걸 추가하는게 정석에 맞는 코드 작성 방식

    def swim(self):
        return '엄마가 수영'


class Dad(Person):
    gene = 'XY'

    def __init__(self, name):
        super().__init__(name)

    def walk(self):
        return '아빠가 걷기'


class FirtChild(Dad, Mom):
    mom_gene = Mom.gene # 이걸 추가하면 상속 순서를 바꾸지 않고도 Mom의 gene 사용 가능

    def __init__(self, name):
        super().__init__(name)

    def swim(self):
        return '첫째가 수영'
    
    def cry(self):
        return '첫째가 응애'



baby1 = FirtChild('아가')
print(baby1.cry()) # 첫째가 응애
print(baby1.swim()) # 첫째가 수영
print(baby1.walk()) # 아빠가 걷기
print(baby1.gene) # XY, Dad를 먼저 상속했기 때문에. Person에서 'XYZ'여도 이런 결과
print(baby1.mom_gene)

print(FirstChild.mro())
# [<class '__main__.FirstChild'>, <class '__main__.Dad'>, <class '__main__.Mom'>, <class '__main__.Person'>, <class 'object'>]
# 상속 순서를 알려줌
```



**23p**

버그 bug



**27p**

디버깅 방법

- print 함수 활용: 결과를 나눠서 생각하면서 확인하면서 가



**p**



**30p**

문법 에러 Syntax Error

예외 Exception



**35p**

내장 예외 Built-in Exceptions

- 파이썬에서 이미 정의되어 있으며, 특정 예외 상황에 대한 처리를 위해 사용



**48p**

```python
try:
    # 예외가 발생할 수 있는 코드
    
except 예외:
    # 예외 처리 코드

# 예외가 발생하면 프로그램 흐름은 try 블록을 빠져나와 해당 예외에 대응하는 except 블록으로 이동
```



**50p**

input으로 받는 경우 문자열로 처리가 될 것이기 때문에 int를 해준다.

```python
try:
    num = int(input('100으로 나눌 값을 입력해: '))
    print(100 / num)

except ValueError:
    print('숫자를 입력하라고')

except ZeroDivisionError:
    '''
    에러도 상위 하위 class의 개념이 있다.
    만약 ValueError가 ZeroDivisionError의 상위 class라면,
    절대 ZeroDivisionError가 실행 될 일이 없다.
    
    따라서 이러한 경우 하위 class를 먼저 써줘야
    에러에 대한 적절한 대응을 할 수 있다.
    '''
    print('왜 0을 입력하는거야??')

except:
    print('에러가 발생했어')
    
혹은

except (ValueError, ZeroDivisionError) :
    print('제대로 입력하라고')
```

```python
try:
    num = int(input('100으로 나눌 값을 입력해: '))
    print(100 / num)

except BaseException:
    print('숫자를 입력하라고')

except ZeroDivisionError:
    print('왜 0을 입력하는거야??')

except:
    print('에러가 발생했어')
    
# ZeroDivisionError은 BaseException의 하위 class이기 때문에,
# 이렇게 코드를 작성하면 실제로 실행될 일 없는 코드는 흐려진다.
# 이 경우 0을 입력해도 '숫자를 입력하라고'가 출력된다.
```



**55p**

**반드시 하위 클래스를 먼저 확인하도록 순서에 유의하여 작성해야한다.**

예외 간의 상속 구조를 확인할 수 있는 링크



**59p**

EAFP

- 허락보다 용서를 구하는게 더 쉽다.
- 일단 질러놓고 보자
- 예외처리를 중심으로 코드를 작성하는 접근 방식



**60p**

LBYL

- 값 검사를 중심으로 코드를 작성



**66p**

as: 에러 메세지도 활용 가능

error는 변수 명일 뿐이기 때문에 다른걸로도 가능
